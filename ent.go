package ent

import (
	"errors"
	"fmt"
	"reflect"
	"sync"
	"unsafe"
)

type Ent interface {
	Id() uint64
	Version() uint64
	HasUnsavedChanges() bool

	EntTypeName() string
	EntNew() Ent
	EntEncode(c Encoder, fieldmap uint64)
	EntDecode(c Decoder) (id, version uint64)
	EntDecodeIndexed(c Decoder, fields uint64) (version uint64)
	EntIndexes() []EntIndex

	entUnsafePtr() unsafe.Pointer // pointer to EntBase (and thus header of Ent)
}

type EntBase struct {
	id      uint64
	version uint64
	storage Storage

	// fieldmap is a bitmap where each bit represents a struct field index.
	// A set bit indicates that the field's value has changed since the last call to Load()
	fieldmap uint64
}

const (
	fieldmapAll  = uint64(0xFFFFFFFFFFFFFFFF)
	fieldmapNone = uint64(0)
)

var (
	ErrNoStorage       = errors.New("no ent storage")
	ErrNotFound        = errors.New("ent not found")
	ErrVersionConflict = errors.New("version conflict")
	ErrDuplicateEnt    = errors.New("duplicate ent")
)

var (
	FieldNameVersion = "_ver"
	FieldNameId      = "_id"
)

type Id uint64

func entBase(e Ent) *EntBase                    { return (*EntBase)(e.entUnsafePtr()) }
func (e *EntBase) entUnsafePtr() unsafe.Pointer { return unsafe.Pointer(e) }

func (e *EntBase) Id() uint64              { return e.id }
func (e *EntBase) Version() uint64         { return e.version }
func (e *EntBase) HasUnsavedChanges() bool { return e.fieldmap != 0 }

// these are just stubs; actual implementations generated by entgen
func (e *EntBase) EntTypeName() string       { return "_" }
func (e *EntBase) EntEncode(Encoder, uint64) {}
func (e *EntBase) EntDecode(c Decoder) (id, version uint64) {
	// Default implementation which discards any fields apart from "special" fields
	for {
		key := c.Key()
		if key == "" {
			break
		}
		switch string(key) {
		case FieldNameId:
			id = c.Uint(64)
		case FieldNameVersion:
			version = c.Uint(64)
		default:
			c.Discard()
		}
	}
	return
}

func (e *EntBase) EntIsFieldChanged(fieldIndex int) bool {
	return IsFieldChanged(e, fieldIndex)
}

func (e *EntBase) EntIndexes() []EntIndex { return nil }

// SetFieldChanged marks the field fieldIndex as "having unsaved changes"
func SetFieldChanged(e *EntBase, fieldIndex int) { e.fieldmap |= (1 << fieldIndex) }

// ClearFieldChanged marks the field fieldIndex as not having and unsaved changes
func ClearFieldChanged(e *EntBase, fieldIndex int) { e.fieldmap &= ^(1 << fieldIndex) }

// IsFieldChanged returns true if the field fieldIndex is marked as "having unsaved changes"
func IsFieldChanged(e *EntBase, fieldIndex int) bool {
	return (e.fieldmap & (1 << fieldIndex)) != 0
}

// JsonEncode encodes the ent as JSON
func JsonEncode(e Ent) ([]byte, error) {
	// Note: Used by generated code to implement MarshalJSON
	return jsonEncodeEnt(e, e.Id(), e.Version(), fieldmapAll)
}

// JsonEncodeUnsaved encodes the ent as JSON, only including fields with unsaved changes
func JsonEncodeUnsaved(e Ent) ([]byte, error) {
	eb := entBase(e)
	return jsonEncodeEnt(e, e.Id(), e.Version(), eb.fieldmap)
}

// JsonEncode encodes the ent as JSON
func JsonDecode(e Ent, data []byte) error {
	// Note: Used by generated code to implement UnmarshalJSON
	id, version, err := jsonDecodeEnt(e, data)
	if err == nil {
		eb := entBase(e)
		eb.id = id
		eb.version = version
	}
	return err
}

// —————————————————————————————————————————————————————————
// registry
// All ents are expected to call Register during program initialization, either through
// an empty var assignment or init() function. e.g. var _ = ent.Register(&MyEnt{})
// Register is concurrency safe and can be called from any goroutine at any time.

type EntType struct {
	Name string // == EntTypeName()
	Type reflect.Type
}

var (
	entRegMapMu sync.RWMutex
	entRegMap   = map[string]*EntType{}

	entBaseType = reflect.TypeOf(EntBase{})
)

func Register(e Ent) *EntType {
	et := &EntType{
		Name: e.EntTypeName(),
		Type: reflect.TypeOf(e),
	}
	entRegMapMu.Lock()
	defer entRegMapMu.Unlock()
	if existingEntType := entRegMap[et.Name]; existingEntType != nil {
		if et.Type == existingEntType.Type {
			// ignore duplicate call to Register
			return existingEntType
		}
		panic(fmt.Sprintf("duplicate ent type name %q", et.Name))
	}
	entRegMap[et.Name] = et
	return et
}

func EntTypeByName(typename string) *EntType {
	entRegMapMu.RLock()
	t := entRegMap[typename]
	entRegMapMu.RUnlock()
	return t
}

func TypeOf(e Ent) *EntType {
	return EntTypeByName(e.EntTypeName())
}

// SetEntBaseFieldsAfterLoad sets values of EntBase fields.
// This function is meant to be used by Storage implementation, called after a new ent has been
// loaded or created.
func SetEntBaseFieldsAfterLoad(e Ent, s Storage, id, version uint64) {
	eb := entBase(e)
	eb.id = id
	eb.version = version
	eb.storage = s
	eb.fieldmap = 0
}

// —————————————————————————————————————————————————————————
// CRUD
// C = CreateEnt(Ent,Storage)
// R = LoadEntById(Ent,Storage,id), ReloadEnt(Ent)
// U = SaveEnt(Ent)
// D = DeleteEnt(Ent)

func CreateEnt(e Ent, storage Storage) error {
	if storage == nil {
		return ErrNoStorage
	}
	eb := entBase(e)
	id, err := storage.CreateEnt(e, eb.fieldmap)
	if err == nil {
		eb.id = id
		eb.version = 1
		eb.storage = storage
		eb.fieldmap = 0
	}
	return err
}

func LoadEntById(e Ent, storage Storage, id uint64) error {
	if storage == nil {
		return ErrNoStorage
	}
	if id == 0 {
		return ErrNotFound
	}
	version, err := storage.LoadEntById(e, id)
	if err == nil {
		SetEntBaseFieldsAfterLoad(e, storage, id, version)
	}
	return err
}

func ReloadEnt(e Ent) error {
	eb := entBase(e)
	return LoadEntById(e, eb.storage, eb.id)
}

func SaveEnt(e Ent) error {
	eb := entBase(e)
	if eb.storage == nil {
		return ErrNoStorage
	}
	if eb.fieldmap == 0 {
		return nil
	}
	version, err := eb.storage.SaveEnt(e, eb.fieldmap)
	if err == nil {
		eb.version = version
		eb.fieldmap = 0
	}
	return err
}

func DeleteEnt(e Ent) error {
	eb := entBase(e)
	if eb.storage == nil {
		return ErrNoStorage
	}
	err := eb.storage.DeleteEnt(e)
	if err == nil {
		eb.id = 0
		eb.version = 0
		eb.storage = nil
		eb.fieldmap = 0
	}
	return err
}
