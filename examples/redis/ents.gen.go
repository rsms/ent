// +build !entgen

// Code generated by entgen. DO NOT EDIT. by entgen. Edit with caution!
package main

import "github.com/rsms/ent"

// ----------------------------------------------------------------------------
// Account

// LoadAccountById loads Account with id from storage
func LoadAccountById(storage ent.Storage, id uint64) (*Account, error) {
	e := &Account{}
	return e, ent.LoadEntById(e, storage, id)
}

// LoadAccountByEmail loads Account with email
func LoadAccountByEmail(s ent.Storage, email string) (*Account, error) {
	e := &Account{}
	err := ent.LoadEntByIndexKey(s, e, &ent_Account_idx[0], []byte(email))
	return e, err
}

// FindAccountByEmail looks up Account id with email
func FindAccountByEmail(s ent.Storage, email string) (uint64, error) {
	return ent.FindEntIdByIndexKey(s, "account", &ent_Account_idx[0], []byte(email))
}

// LoadAccountByName loads all Account ents with name
func LoadAccountByName(s ent.Storage, name string, limit int) ([]*Account, error) {
	e := &Account{}
	r, err := s.LoadEntsByIndex(e, &ent_Account_idx[1], []byte(name), limit)
	return ent_Account_slice_cast(r), err
}

// FindAccountByName looks up Account ids with name
func FindAccountByName(s ent.Storage, name string, limit int) ([]uint64, error) {
	return s.FindEntIdsByIndex("account", &ent_Account_idx[1], []byte(name), limit)
}

// EntTypeName returns the ent's storage name ("account")
func (e Account) EntTypeName() string { return "account" }

// EntNew returns a new empty Account. Used by the ent package for loading ents.
func (e Account) EntNew() ent.Ent { return &Account{} }

// MarshalJSON returns a JSON representation of e. Conforms to json.Marshaler.
func (e *Account) MarshalJSON() ([]byte, error) { return ent.JsonEncode(e) }

// UnmarshalJSON populates the ent from JSON data. Conforms to json.Unmarshaler.
func (e *Account) UnmarshalJSON(b []byte) error { return ent.JsonDecode(e, b) }

// Create a new account ent in storage
func (e *Account) Create(storage ent.Storage) error { return ent.CreateEnt(e, storage) }

// Save pending changes to whatever storage this ent was created or loaded from
func (e *Account) Save() error { return ent.SaveEnt(e) }

// Reload fields to latest values from storage, discarding any unsaved changes
func (e *Account) Reload() error { return ent.ReloadEnt(e) }

// PermanentlyDelete deletes this ent from storage. This can usually not be undone.
func (e *Account) PermanentlyDelete() error { return ent.DeleteEnt(e) }

// ---- field accessor methods ----

func (e *Account) Name() string         { return e.name }
func (e *Account) Email() string        { return e.email }
func (e *Account) EmailVerified() bool  { return e.emailVerified }
func (e *Account) Deleted() bool        { return e.deleted }
func (e *Account) PasswordHash() string { return e.passwordHash }

func (e *Account) SetName(v string)         { e.name = v; ent.SetFieldChanged(&e.EntBase, 0) }
func (e *Account) SetEmail(v string)        { e.email = v; ent.SetFieldChanged(&e.EntBase, 1) }
func (e *Account) SetEmailVerified(v bool)  { e.emailVerified = v; ent.SetFieldChanged(&e.EntBase, 2) }
func (e *Account) SetDeleted(v bool)        { e.deleted = v; ent.SetFieldChanged(&e.EntBase, 3) }
func (e *Account) SetPasswordHash(v string) { e.passwordHash = v; ent.SetFieldChanged(&e.EntBase, 4) }

// ---- encode & decode methods ----

func (e *Account) EntEncode(c ent.Encoder, fields uint64) {
	if (fields & (1 << 0)) != 0 {
		c.Key("name")
		c.Str(e.name)
	}
	if (fields & (1 << 1)) != 0 {
		c.Key("email")
		c.Str(e.email)
	}
	if (fields & (1 << 2)) != 0 {
		c.Key("email_verified")
		c.Bool(e.emailVerified)
	}
	if (fields & (1 << 3)) != 0 {
		c.Key("deleted")
		c.Bool(e.deleted)
	}
	if (fields & (1 << 4)) != 0 {
		c.Key("pwhash")
		c.Str(e.passwordHash)
	}
}

// EntDecode populates fields from a decoder
func (e *Account) EntDecode(c ent.Decoder) (id, version uint64) {
	for {
		switch string(c.Key()) {
		case "":
			return
		case ent.FieldNameId:
			id = c.Uint(64)
		case ent.FieldNameVersion:
			version = c.Uint(64)
		case "name":
			e.name = c.Str()
		case "email":
			e.email = c.Str()
		case "email_verified":
			e.emailVerified = c.Bool()
		case "deleted":
			e.deleted = c.Bool()
		case "pwhash":
			e.passwordHash = c.Str()
		default:
			c.Discard()
		}
	}
	return
}

// EntDecodePartial is used internally by ent.Storage during updates.
func (e *Account) EntDecodePartial(c ent.Decoder, fields uint64) (version uint64) {
	for n := 2; n > 0; {
		switch string(c.Key()) {
		case "":
			return
		case ent.FieldNameVersion:
			version = c.Uint(64)
			continue
		case "name":
			n--
			if (fields & (1 << 0)) != 0 {
				e.name = c.Str()
				continue
			}
		case "email":
			n--
			if (fields & (1 << 1)) != 0 {
				e.email = c.Str()
				continue
			}
		}
		c.Discard()
	}
	return
}

// Symbolic field indices, for use with ent.*FieldChanged methods
const (
	ent_Account_f_name          = 0
	ent_Account_f_email         = 1
	ent_Account_f_emailVerified = 2
	ent_Account_f_deleted       = 3
	ent_Account_f_passwordHash  = 4
)

// EntFields returns information about Account fields
var ent_Account_fields = ent.Fields{
	Names: []string{
		"name",
		"email",
		"email_verified",
		"deleted",
		"pwhash",
	},
	Fieldmap: 0b11111,
}

// EntFields returns information about Account fields
func (e Account) EntFields() ent.Fields { return ent_Account_fields }

// Indexes (Name, Fields, Flags)
var ent_Account_idx = []ent.EntIndex{
	{"email", 1 << ent_Account_f_email, ent.EntIndexUnique},
	{"name", 1 << ent_Account_f_name, 0},
}

// EntIndexes returns information about secondary indexes
func (e *Account) EntIndexes() []ent.EntIndex { return ent_Account_idx }

// ---- helpers ----

func ent_Account_slice_cast(s []ent.Ent) []*Account {
	v := make([]*Account, len(s))
	for i := 0; i < len(s); i++ {
		v[i] = s[i].(*Account)
	}
	return v
}
