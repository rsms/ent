// +build !entgen

// Code generated by entgen. DO NOT EDIT.
package main

import "github.com/rsms/ent"

// ----------------------------------------------------------------------------
// Account

// LoadAccountById loads Account with id from storage
func LoadAccountById(storage ent.Storage, id uint64) (*Account, error) {
	e := &Account{}
	return e, ent.LoadEntById(e, storage, id)
}

// LoadAccountByEmail loads Account with email
func LoadAccountByEmail(s ent.Storage, email string, fl ...ent.LookupFlags) (*Account, error) {
	e := &Account{}
	err := ent.LoadEntByIndexKey(s, e, &ent_Account_idx[0], []byte(email), fl)
	return e, err
}

// FindAccountByEmail looks up Account id with email
func FindAccountByEmail(s ent.Storage, email string, fl ...ent.LookupFlags) (uint64, error) {
	return ent.FindIdByIndexKey(s, "account", &ent_Account_idx[0], []byte(email), fl)
}

// LoadAccountByName loads all Account ents with name
func LoadAccountByName(s ent.Storage, name string, limit int, fl ...ent.LookupFlags) ([]*Account, error) {
	e := &Account{}
	r, err := ent.LoadEntsByIndexKey(s, e, &ent_Account_idx[1], []byte(name), limit, fl)
	return ent_Account_slice_cast(r), err
}

// FindAccountByName looks up Account ids with name
func FindAccountByName(s ent.Storage, name string, limit int, fl ...ent.LookupFlags) ([]uint64, error) {
	return ent.FindIdsByIndexKey(s, "account", &ent_Account_idx[1], []byte(name), limit, fl)
}

// EntTypeName returns the ent's storage name ("account")
func (e Account) EntTypeName() string { return "account" }

// EntStorage returns the storage this ent belongs to or nil if it doesn't belong anywhere.
func (e *Account) EntStorage() ent.Storage { return ent.GetStorage(e) }

// EntNew returns a new empty Account. Used by the ent package for loading ents.
func (e Account) EntNew() ent.Ent { return &Account{} }

// MarshalJSON returns a JSON representation of e. Conforms to json.Marshaler.
func (e *Account) MarshalJSON() ([]byte, error) { return ent.JsonEncode(e, "") }

// UnmarshalJSON populates the ent from JSON data. Conforms to json.Unmarshaler.
func (e *Account) UnmarshalJSON(b []byte) error { return ent.JsonDecode(e, b) }

// String returns a JSON representation of e.
func (e Account) String() string { return ent.EntString(&e) }

// Create a new account ent in storage
func (e *Account) Create(storage ent.Storage) error { return ent.CreateEnt(e, storage) }

// Save pending changes to whatever storage this ent was created or loaded from
func (e *Account) Save() error { return ent.SaveEnt(e) }

// Reload fields to latest values from storage, discarding any unsaved changes
func (e *Account) Reload() error { return ent.ReloadEnt(e) }

// PermanentlyDelete deletes this ent from storage. This can usually not be undone.
func (e *Account) PermanentlyDelete() error { return ent.DeleteEnt(e) }

// Iterator returns an iterator over all Account ents. Order is undefined.
func (e Account) Iterator(s ent.Storage) ent.EntIterator { return s.IterateEnts(&e) }

// ---- field accessor methods ----

func (e *Account) Name() string         { return e.name }
func (e *Account) Email() string        { return e.email }
func (e *Account) EmailVerified() bool  { return e.emailVerified }
func (e *Account) Deleted() bool        { return e.deleted }
func (e *Account) PasswordHash() string { return e.passwordHash }

func (e *Account) SetName(v string)         { e.name = v; e.EntBase.SetEntFieldChanged(0) }
func (e *Account) SetEmail(v string)        { e.email = v; e.EntBase.SetEntFieldChanged(1) }
func (e *Account) SetEmailVerified(v bool)  { e.emailVerified = v; e.EntBase.SetEntFieldChanged(2) }
func (e *Account) SetDeleted(v bool)        { e.deleted = v; e.EntBase.SetEntFieldChanged(3) }
func (e *Account) SetPasswordHash(v string) { e.passwordHash = v; e.EntBase.SetEntFieldChanged(4) }

// SetNameIfDifferent sets name only if v is different from the current value.
func (e *Account) SetNameIfDifferent(v string) bool {
	if e.name == v {
		return false
	}
	e.SetName(v)
	return true
}

// SetEmailIfDifferent sets email only if v is different from the current value.
func (e *Account) SetEmailIfDifferent(v string) bool {
	if e.email == v {
		return false
	}
	e.SetEmail(v)
	return true
}

// SetEmailVerifiedIfDifferent sets emailVerified only if v is different from the current value.
func (e *Account) SetEmailVerifiedIfDifferent(v bool) bool {
	if e.emailVerified == v {
		return false
	}
	e.SetEmailVerified(v)
	return true
}

// SetDeletedIfDifferent sets deleted only if v is different from the current value.
func (e *Account) SetDeletedIfDifferent(v bool) bool {
	if e.deleted == v {
		return false
	}
	e.SetDeleted(v)
	return true
}

// SetPasswordHashIfDifferent sets passwordHash only if v is different from the current value.
func (e *Account) SetPasswordHashIfDifferent(v string) bool {
	if e.passwordHash == v {
		return false
	}
	e.SetPasswordHash(v)
	return true
}

// ---- encode & decode methods ----

func (e *Account) EntEncode(c ent.Encoder, fields ent.FieldSet) {
	if fields.Has(0) {
		c.Key("name")
		c.Str(e.name)
	}
	if fields.Has(1) {
		c.Key("email")
		c.Str(e.email)
	}
	if fields.Has(2) {
		c.Key("email_verified")
		c.Bool(e.emailVerified)
	}
	if fields.Has(3) {
		c.Key("deleted")
		c.Bool(e.deleted)
	}
	if fields.Has(4) {
		c.Key("pwhash")
		c.Str(e.passwordHash)
	}
}

// EntDecode populates fields from a decoder
func (e *Account) EntDecode(c ent.Decoder) (id, version uint64) {
	for {
		switch string(c.Key()) {
		case "":
			return
		case ent.FieldNameId:
			id = c.Uint(64)
		case ent.FieldNameVersion:
			version = c.Uint(64)
		case "name":
			e.name = c.Str()
		case "email":
			e.email = c.Str()
		case "email_verified":
			e.emailVerified = c.Bool()
		case "deleted":
			e.deleted = c.Bool()
		case "pwhash":
			e.passwordHash = c.Str()
		default:
			c.Discard()
		}
	}
	return
}

// EntDecodePartial is used internally by ent.Storage during updates.
func (e *Account) EntDecodePartial(c ent.Decoder, fields ent.FieldSet) (version uint64) {
	for n := 2; n > 0; {
		switch string(c.Key()) {
		case "":
			return
		case ent.FieldNameVersion:
			version = c.Uint(64)
			continue
		case "name":
			n--
			if fields.Has(0) {
				e.name = c.Str()
				continue
			}
		case "email":
			n--
			if fields.Has(1) {
				e.email = c.Str()
				continue
			}
		}
		c.Discard()
	}
	return
}

// Symbolic field indices, for use with ent.*FieldChanged methods
const (
	ent_Account_f_name          = 0
	ent_Account_f_email         = 1
	ent_Account_f_emailVerified = 2
	ent_Account_f_deleted       = 3
	ent_Account_f_passwordHash  = 4
)

// EntFields returns information about Account fields
var ent_Account_fields = ent.Fields{
	Names: []string{
		"name",
		"email",
		"email_verified",
		"deleted",
		"pwhash",
	},
	FieldSet: 0b11111,
}

// EntFields returns information about Account fields
func (e Account) EntFields() ent.Fields { return ent_Account_fields }

// Indexes (Name, Fields, Flags)
var ent_Account_idx = []ent.EntIndex{
	{"email", 1 << ent_Account_f_email, ent.EntIndexUnique},
	{"name", 1 << ent_Account_f_name, 0},
}

// EntIndexes returns information about secondary indexes
func (e *Account) EntIndexes() []ent.EntIndex { return ent_Account_idx }

// ----------------------------------------------------------------------------
// Department

// LoadDepartmentById loads Department with id from storage
func LoadDepartmentById(storage ent.Storage, id uint64) (*Department, error) {
	e := &Department{}
	return e, ent.LoadEntById(e, storage, id)
}

// LoadDepartmentByBuilding loads all Department ents with building
func LoadDepartmentByBuilding(s ent.Storage, building Building, limit int, fl ...ent.LookupFlags) ([]*Department, error) {
	e := &Department{}
	r, err := ent.LoadEntsByIndex(s, e, &ent_Department_idx[0], limit, fl, 1, func(c ent.Encoder) {
		c.Int(int64(building), 32)
	})
	return ent_Department_slice_cast(r), err
}

// FindDepartmentByBuilding looks up Department ids with building
func FindDepartmentByBuilding(s ent.Storage, building Building, limit int, fl ...ent.LookupFlags) ([]uint64, error) {
	return ent.FindIdsByIndex(s, "dept", &ent_Department_idx[0], limit, fl, 1, func(c ent.Encoder) {
		c.Int(int64(building), 32)
	})
}

// EntTypeName returns the ent's storage name ("dept")
func (e Department) EntTypeName() string { return "dept" }

// EntStorage returns the storage this ent belongs to or nil if it doesn't belong anywhere.
func (e *Department) EntStorage() ent.Storage { return ent.GetStorage(e) }

// EntNew returns a new empty Department. Used by the ent package for loading ents.
func (e Department) EntNew() ent.Ent { return &Department{} }

// MarshalJSON returns a JSON representation of e. Conforms to json.Marshaler.
func (e *Department) MarshalJSON() ([]byte, error) { return ent.JsonEncode(e, "") }

// UnmarshalJSON populates the ent from JSON data. Conforms to json.Unmarshaler.
func (e *Department) UnmarshalJSON(b []byte) error { return ent.JsonDecode(e, b) }

// String returns a JSON representation of e.
func (e Department) String() string { return ent.EntString(&e) }

// Create a new dept ent in storage
func (e *Department) Create(storage ent.Storage) error { return ent.CreateEnt(e, storage) }

// Save pending changes to whatever storage this ent was created or loaded from
func (e *Department) Save() error { return ent.SaveEnt(e) }

// Reload fields to latest values from storage, discarding any unsaved changes
func (e *Department) Reload() error { return ent.ReloadEnt(e) }

// PermanentlyDelete deletes this ent from storage. This can usually not be undone.
func (e *Department) PermanentlyDelete() error { return ent.DeleteEnt(e) }

// Iterator returns an iterator over all Department ents. Order is undefined.
func (e Department) Iterator(s ent.Storage) ent.EntIterator { return s.IterateEnts(&e) }

// ---- field accessor methods ----

func (e *Department) Name() string       { return e.name }
func (e *Department) Building() Building { return e.building }

func (e *Department) SetName(v string)       { e.name = v; e.EntBase.SetEntFieldChanged(0) }
func (e *Department) SetBuilding(v Building) { e.building = v; e.EntBase.SetEntFieldChanged(1) }

// SetNameIfDifferent sets name only if v is different from the current value.
func (e *Department) SetNameIfDifferent(v string) bool {
	if e.name == v {
		return false
	}
	e.SetName(v)
	return true
}

// SetBuildingIfDifferent sets building only if v is different from the current value.
func (e *Department) SetBuildingIfDifferent(v Building) bool {
	if e.building == v {
		return false
	}
	e.SetBuilding(v)
	return true
}

// ---- encode & decode methods ----

func (e *Department) EntEncode(c ent.Encoder, fields ent.FieldSet) {
	if fields.Has(0) {
		c.Key("name")
		c.Str(e.name)
	}
	if fields.Has(1) {
		c.Key("building")
		c.Int(int64(e.building), 32)
	}
}

// EntDecode populates fields from a decoder
func (e *Department) EntDecode(c ent.Decoder) (id, version uint64) {
	for {
		switch string(c.Key()) {
		case "":
			return
		case ent.FieldNameId:
			id = c.Uint(64)
		case ent.FieldNameVersion:
			version = c.Uint(64)
		case "name":
			e.name = c.Str()
		case "building":
			e.building = Building(c.Int(32))
		default:
			c.Discard()
		}
	}
	return
}

// EntDecodePartial is used internally by ent.Storage during updates.
func (e *Department) EntDecodePartial(c ent.Decoder, fields ent.FieldSet) (version uint64) {
	for n := 1; n > 0; {
		switch string(c.Key()) {
		case "":
			return
		case ent.FieldNameVersion:
			version = c.Uint(64)
			continue
		case "building":
			n--
			if fields.Has(1) {
				e.building = Building(c.Int(32))
				continue
			}
		}
		c.Discard()
	}
	return
}

// Symbolic field indices, for use with ent.*FieldChanged methods
const (
	ent_Department_f_name     = 0
	ent_Department_f_building = 1
)

// EntFields returns information about Department fields
var ent_Department_fields = ent.Fields{
	Names: []string{
		"name",
		"building",
	},
	FieldSet: 0b11,
}

// EntFields returns information about Department fields
func (e Department) EntFields() ent.Fields { return ent_Department_fields }

// Indexes (Name, Fields, Flags)
var ent_Department_idx = []ent.EntIndex{
	{"building", 1 << ent_Department_f_building, 0},
}

// EntIndexes returns information about secondary indexes
func (e *Department) EntIndexes() []ent.EntIndex { return ent_Department_idx }

// ---- helpers ----

func ent_Account_slice_cast(s []ent.Ent) []*Account {
	v := make([]*Account, len(s))
	for i := 0; i < len(s); i++ {
		v[i] = s[i].(*Account)
	}
	return v
}

func ent_Department_slice_cast(s []ent.Ent) []*Department {
	v := make([]*Department, len(s))
	for i := 0; i < len(s); i++ {
		v[i] = s[i].(*Department)
	}
	return v
}
